//
// Generated by Bluespec Compiler, version 2010.04.beta2 (build 20501, 2010-04-14)
//
// On Tue Mar 22 15:01:06 EDT 2011
//
// Method conflict info:
// Method: enq
// Conflict-free: pop
// Conflicts: enq
//
// Method: pop
// Conflict-free: enq
// Conflicts: pop
//
//
// Ports:
// Name                         I/O  size props
// RDY_enq                        O     1
// pop                            O    32
// RDY_pop                        O     1
// CLK_sClk                       I     1 clock
// RST_N_sRst                     I     1 reset
// CLK                            I     1 clock
// RST_N                          I     1 reset
// enq_bits                       I    16
// EN_enq                         I     1
// EN_pop                         I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkFIFO16to32ToCC(CLK_sClk,
			RST_N_sRst,
			CLK,
			RST_N,

			enq_bits,
			EN_enq,
			RDY_enq,

			EN_pop,
			pop,
			RDY_pop);
  input  CLK_sClk;
  input  RST_N_sRst;
  input  CLK;
  input  RST_N;

  // action method enq
  input  [15 : 0] enq_bits;
  input  EN_enq;
  output RDY_enq;

  // actionvalue method pop
  input  EN_pop;
  output [31 : 0] pop;
  output RDY_pop;

  // signals for module outputs
  wire [31 : 0] pop;
  wire RDY_enq, RDY_pop;

  // register m_msb
  reg [15 : 0] m_msb;
  wire [15 : 0] m_msb$D_IN;
  wire m_msb$EN;

  // register m_popReady
  reg m_popReady;
  wire m_popReady$D_IN, m_popReady$EN;

  // ports of submodule m_infifo
  wire [15 : 0] m_infifo$dD_OUT, m_infifo$sD_IN;
  wire m_infifo$dDEQ, m_infifo$dEMPTY_N, m_infifo$sENQ, m_infifo$sFULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_m_shift;

  // action method enq
  assign RDY_enq = m_infifo$sFULL_N ;

  // actionvalue method pop
  assign pop = { m_msb, m_infifo$dD_OUT } ;
  assign RDY_pop = m_infifo$dEMPTY_N && m_popReady ;

  // submodule m_infifo
  SyncFIFO #(.dataWidth(32'd16),
	     .depth(32'd64),
	     .indxWidth(32'd6),
	     .regFull(1'd1),
	     .regEmpty(1'd1)) m_infifo(.sCLK(CLK_sClk),
				       .dCLK(CLK),
				       .sRST_N(RST_N_sRst),
				       .sD_IN(m_infifo$sD_IN),
				       .sENQ(m_infifo$sENQ),
				       .dDEQ(m_infifo$dDEQ),
				       .dD_OUT(m_infifo$dD_OUT),
				       .sFULL_N(m_infifo$sFULL_N),
				       .dEMPTY_N(m_infifo$dEMPTY_N));

  // rule RL_m_shift
  assign WILL_FIRE_RL_m_shift = m_infifo$dEMPTY_N && !m_popReady ;

  // register m_msb
  assign m_msb$D_IN = m_infifo$dD_OUT ;
  assign m_msb$EN = WILL_FIRE_RL_m_shift ;

  // register m_popReady
  assign m_popReady$D_IN = !EN_pop ;
  assign m_popReady$EN = EN_pop || WILL_FIRE_RL_m_shift ;

  // submodule m_infifo
  assign m_infifo$sD_IN = enq_bits ;
  assign m_infifo$sENQ = EN_enq ;
  assign m_infifo$dDEQ = WILL_FIRE_RL_m_shift || EN_pop ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        m_msb <= `BSV_ASSIGNMENT_DELAY 16'd0;
	m_popReady <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (m_msb$EN) m_msb <= `BSV_ASSIGNMENT_DELAY m_msb$D_IN;
	if (m_popReady$EN)
	  m_popReady <= `BSV_ASSIGNMENT_DELAY m_popReady$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    m_msb = 16'hAAAA;
    m_popReady = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFIFO16to32ToCC

